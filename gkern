#!/bin/bash

# generation du boot
cc -m32 -traditional -E -Iinclude boot/bootsect.S > tmp/bootsect.s 
as86 -0 -a -o tmp/bootsect.o tmp/bootsect.s
ld86 -0 -s -o tmp/bootsect tmp/bootsect.o
cc -m32 -traditional -E -Iinclude boot/setup.S > tmp/setup.s
as86 -0 -a -o tmp/setup.o tmp/setup.s
ld86 -0 -s -o tmp/setup tmp/setup.o

# generation du mini_kernel de base 
gcc -m32 minikernel_init/gidt.c -o tmp/gidt ; tmp/gidt > minikernel_init/idt.h
gcc -m32 -fno-stack-protector -traditional -Iinclude -c minikernel_init/head.S -o tmp/head.o
gcc -m32 -fno-stack-protector -Iinclude -c minikernel_init/util.c -o tmp/util.o
gcc -m32 -fno-stack-protector -Iinclude -c minikernel_init/vga.c -o tmp/vga.o
gcc -m32 -fno-stack-protector -Iinclude -c minikernel_init/main.c -o tmp/main.o
gcc -m32 -fno-stack-protector -Iinclude -c minikernel_init/process.c -o tmp/process.o
gcc -m32 -fno-stack-protector -Iinclude -c minikernel_init/syscalls.c -o tmp/syscalls.o
gcc -m32 -fno-stack-protector -Iinclude -c minikernel_init/keyboard.c -o tmp/keyboard.o
gcc -m32 -fno-stack-protector -Iinclude -c minikernel_init/ttyS_asm.S -o tmp/ttyS_asm.o
gcc -m32 -fno-stack-protector -Iinclude -c minikernel_init/ttyS.c -o tmp/ttyS.o


# generation du mini_kernel  user 
gcc -m32 -fno-stack-protector -Iinclude -c minikernel_user/test.S -o tmp/user_test.o
gcc -m32 -fno-stack-protector -Iinclude -c minikernel_user/entry.c -o tmp/entry.o
gcc -m32 -fno-stack-protector -Iinclude -c minikernel_user/ttyS_util.S -o tmp/ttyS_util.o

# generation du kernel
ld -m elf_i386 -Ttext 0x1000 -e startup_32 -o tmp/minikernel.elf  tmp/head.o  tmp/util.o  tmp/vga.o  tmp/main.o  tmp/ttyS_asm.o  tmp/ttyS.o  tmp/user_test.o tmp/entry.o  tmp/ttyS_util.o tmp/keyboard.o tmp/process.o tmp/syscalls.o
objcopy -O binary -R .note -R .comment -S tmp/minikernel.elf tmp/minikernel.bin

# extention du kernel pour faire 32 ko, comme ça on sait où sera la table
dd if=tmp/minikernel.bin of=tmp/minikernel.extended count=1 bs=32768 conv=sync

# generation des processus user

# generation de la table des points d'entrées. celle-ci est bidon et sert pour des tests
echo -e "A00\x00B00\x00C00\x00D00\x00" > tmp/table

# ajout de la table après le kernel. a modifier pour mettre les processus aussi
cat tmp/minikernel.extended tmp/table > tmp/minikernel

# generation de l'image bootable
test -f tmp/build || cc boot/build.c -o tmp/build
tmp/build tmp/bootsect tmp/setup tmp/minikernel > mykernel
dd if=mykernel of=mykernel.vfd count=1 bs=1474560 conv=sync
